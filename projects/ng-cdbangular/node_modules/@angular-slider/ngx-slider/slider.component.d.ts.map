{"version":3,"file":"slider.component.d.ts","sources":["slider.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { OnInit, AfterViewInit, OnChanges, OnDestroy, ElementRef, Renderer2, EventEmitter, TemplateRef, ChangeDetectorRef, SimpleChanges, NgZone } from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Options } from './options';\nimport { ChangeContext } from './change-context';\nexport declare class Tick {\n    selected: boolean;\n    style: any;\n    tooltip: string;\n    tooltipPlacement: string;\n    value: string;\n    valueTooltip: string;\n    valueTooltipPlacement: string;\n    legend: string;\n}\nexport declare class SliderComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {\n    private renderer;\n    private elementRef;\n    private changeDetectionRef;\n    private zone;\n    value: number;\n    valueChange: EventEmitter<number>;\n    highValue: number;\n    highValueChange: EventEmitter<number>;\n    options: Options;\n    userChangeStart: EventEmitter<ChangeContext>;\n    userChange: EventEmitter<ChangeContext>;\n    userChangeEnd: EventEmitter<ChangeContext>;\n    private manualRefreshSubscription;\n    manualRefresh: EventEmitter<void>;\n    private triggerFocusSubscription;\n    triggerFocus: EventEmitter<void>;\n    readonly range: boolean;\n    private initHasRun;\n    private inputModelChangeSubject;\n    private inputModelChangeSubscription;\n    private outputModelChangeSubject;\n    private outputModelChangeSubscription;\n    private viewLowValue;\n    private viewHighValue;\n    private viewOptions;\n    private handleHalfDimension;\n    private maxHandlePosition;\n    private currentTrackingPointer;\n    private currentFocusPointer;\n    private firstKeyDown;\n    private touchId;\n    private dragging;\n    private leftOuterSelectionBarElement;\n    private rightOuterSelectionBarElement;\n    private fullBarElement;\n    private selectionBarElement;\n    private minHandleElement;\n    private maxHandleElement;\n    private floorLabelElement;\n    private ceilLabelElement;\n    private minHandleLabelElement;\n    private maxHandleLabelElement;\n    private combinedLabelElement;\n    private ticksElement;\n    tooltipTemplate: TemplateRef<any>;\n    sliderElementVerticalClass: boolean;\n    sliderElementAnimateClass: boolean;\n    sliderElementWithLegendClass: boolean;\n    sliderElementDisabledAttr: string;\n    barStyle: any;\n    minPointerStyle: any;\n    maxPointerStyle: any;\n    fullBarTransparentClass: boolean;\n    selectionBarDraggableClass: boolean;\n    ticksUnderValuesClass: boolean;\n    readonly showTicks: boolean;\n    private intermediateTicks;\n    ticks: Tick[];\n    private eventListenerHelper;\n    private onMoveEventListener;\n    private onEndEventListener;\n    private moving;\n    private resizeObserver;\n    private onTouchedCallback;\n    private onChangeCallback;\n    constructor(renderer: Renderer2, elementRef: ElementRef, changeDetectionRef: ChangeDetectorRef, zone: NgZone);\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    writeValue(obj: any): void;\n    registerOnChange(onChangeCallback: any): void;\n    registerOnTouched(onTouchedCallback: any): void;\n    setDisabledState(isDisabled: boolean): void;\n    onResize(event: any): void;\n    private subscribeInputModelChangeSubject(interval?);\n    private subscribeOutputModelChangeSubject(interval?);\n    private subscribeResizeObserver();\n    private unsubscribeResizeObserver();\n    private unsubscribeOnMove();\n    private unsubscribeOnEnd();\n    private unsubscribeInputModelChangeSubject();\n    private unsubscribeOutputModelChangeSubject();\n    private unsubscribeManualRefresh();\n    private unsubscribeTriggerFocus();\n    private getPointerElement(pointerType);\n    private getCurrentTrackingValue();\n    private modelValueToViewValue(modelValue);\n    private viewValueToModelValue(viewValue);\n    private getStepValue(sliderValue);\n    private applyViewChange();\n    private applyInputModelChange(modelChange);\n    private publishOutputModelChange(modelChange);\n    private normaliseModelValues(input);\n    private renormaliseModelValues();\n    private onChangeOptions();\n    private applyOptions();\n    private applyStepsArrayOptions();\n    private applyFloorCeilOptions();\n    private resetSlider(rebindEvents?);\n    private focusPointer(pointerType);\n    private refocusPointerIfNeeded();\n    private manageElementsStyle();\n    private manageEventsBindings();\n    private updateDisabledState();\n    private updateVerticalState();\n    private updateScale();\n    private getAllSliderElements();\n    private initHandles();\n    private addAccessibility();\n    private updateAriaAttributes();\n    private calculateViewDimensions();\n    private calculateViewDimensionsAndDetectChanges();\n    /**\n     * If the slider reference is already destroyed\n     * @returns boolean - true if ref is destroyed\n     */\n    private isRefDestroyed();\n    private updateTicksScale();\n    private getTicksArray();\n    private isTickSelected(value);\n    private updateFloorLabel();\n    private updateCeilLabel();\n    private updateHandles(which, newPos);\n    private getHandleLabelPos(labelType, newPos);\n    private updateLowHandle(newPos);\n    private updateHighHandle(newPos);\n    private updateFloorAndCeilLabelsVisibility();\n    private isLabelBelowFloorLabel(label);\n    private isLabelAboveCeilLabel(label);\n    private updateSelectionBar();\n    private getSelectionBarColor();\n    private getPointerColor(pointerType);\n    private getTickColor(value);\n    private updateCombinedLabel();\n    private getDisplayValue(value, which);\n    private roundStep(value, customStep?);\n    private valueToPosition(val);\n    private positionToValue(position);\n    private getEventXY(event, targetTouchId?);\n    private getEventPosition(event, targetTouchId?);\n    private getNearestHandle(event);\n    private bindEvents();\n    private getOptionsInfluencingEventBindings(options);\n    private unbindEvents();\n    private onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove?, simulateImmediateEnd?);\n    private onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove?, simulateImmediateEnd?);\n    private onMove(event, fromTick?);\n    private onEnd(event);\n    private onPointerFocus(pointerType);\n    private onKeyUp();\n    private onPointerBlur(pointer);\n    private getKeyActions(currentValue);\n    private onKeyboardEvent(event);\n    private onDragStart(pointerType, event, bindMove, bindEnd);\n    /** Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n    private getMinValue(newPos, outOfBounds, isAbove);\n    /** Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n    private getMaxValue(newPos, outOfBounds, isAbove);\n    private onDragMove(event?);\n    private positionTrackingBar(newMinValue, newMaxValue);\n    private positionTrackingHandle(newValue);\n    private applyMinMaxLimit(newValue);\n    private applyMinMaxRange(newValue);\n    private applyPushRange(newValue);\n    private getChangeContext();\n}\n"]}